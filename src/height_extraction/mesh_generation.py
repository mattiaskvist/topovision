"""Module for generating 3D meshes from height extraction output."""

import numpy as np
from scipy.interpolate import griddata

from .schemas import HeightExtractionOutput


def generate_heightmap(
    output: HeightExtractionOutput,
    resolution_scale: float = 1.0,
    interpolation_method: str = "cubic",
) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Generates a dense heightmap from sparse contour lines using interpolation.

    Args:
        output: The HeightExtractionOutput containing contours with heights.
        resolution_scale: Scale factor for the output grid resolution relative to
            the image size. 1.0 means same resolution as image.
        interpolation_method: Method for interpolation ('linear', 'nearest', 'cubic').

    Returns:
        Tuple of (grid_x, grid_y, grid_z) arrays.
    """
    # 1. Collect all points with known heights
    points = []
    values = []

    # We need image dimensions. We can infer them from the max coordinates if not
    # available, but ideally we should read the image. For now, let's find the
    # bounds from contours.
    max_x, max_y = 0, 0

    for contour in output.contours:
        if contour.height is not None:
            for x, y in contour.points:
                points.append((x, y))
                values.append(contour.height)
                max_x = max(max_x, x)
                max_y = max(max_y, y)

        # Update bounds even for contours without height (though we don't use them for
        # interpolation)
        for x, y in contour.points:
            max_x = max(max_x, x)
            max_y = max(max_y, y)

    if not points:
        raise ValueError("No contours with assigned heights found in the output.")

    points = np.array(points)
    values = np.array(values)

    # 2. Create a regular grid
    # Add a small buffer to ensure we cover the edges
    w = int(max_x * resolution_scale) + 1
    h = int(max_y * resolution_scale) + 1

    # Create grid coordinates
    grid_x, grid_y = np.mgrid[0:w, 0:h]

    # Scale grid coordinates back to original image space for interpolation
    # If resolution_scale is 0.5, a grid point at (10, 10) corresponds to (20, 20) in
    # image
    query_points = np.column_stack(
        (grid_x.flatten() / resolution_scale, grid_y.flatten() / resolution_scale)
    )

    # 3. Interpolate
    # griddata expects points as (N, D) and values as (N,)
    # We want to interpolate at query_points
    grid_z = griddata(points, values, query_points, method=interpolation_method)

    # Fill NaNs (outside convex hull of points) with nearest neighbor or min value
    # For a landscape, nearest might be better than 0.
    if np.isnan(grid_z).any():
        grid_z_nearest = griddata(points, values, query_points, method="nearest")
        grid_z[np.isnan(grid_z)] = grid_z_nearest[np.isnan(grid_z)]

    grid_z = grid_z.reshape((w, h))

    return grid_x, grid_y, grid_z


def export_to_obj(
    grid_x: np.ndarray,
    grid_y: np.ndarray,
    grid_z: np.ndarray,
    output_path: str,
    scale_z: float = 1.0,
):
    """Exports the heightmap grid to a Wavefront .obj file.

    Args:
        grid_x: X coordinates of the grid.
        grid_y: Y coordinates of the grid.
        grid_z: Z coordinates (heights) of the grid.
        output_path: Path to save the .obj file.
        scale_z: Multiplier for Z values to exaggerate relief or correct units.
    """
    w, h = grid_x.shape

    with open(output_path, "w") as f:
        f.write("# Generated by Topovision\n")
        f.write("o Landscape\n")

        # Write vertices
        # OBJ format: v x y z
        # We flatten the arrays to iterate easily.
        # Note: Image Y is usually top-down, but 3D world Y is often up.
        # We might want to map Image Y to World Z or -Z, and Height to World Y.
        # Standard convention: X=X, Y=Height, Z=Y (or -Y)
        # Let's stick to X=x, Y=y, Z=height for simplicity, but user might want to
        # rotate later.
        # Actually, let's do X=x, Z=y, Y=height (Y-up is common in 3D)

        for i in range(w):
            for j in range(h):
                x = grid_x[i, j]
                y = grid_z[i, j] * scale_z
                z = grid_y[i, j]
                f.write(f"v {x:.4f} {y:.4f} {z:.4f}\n")

        # Write faces
        # OBJ indices are 1-based
        # Grid is w x h vertices.
        # Vertex index at (i, j) is i * h + j + 1

        for i in range(w - 1):
            for j in range(h - 1):
                # Define quad: (i, j), (i+1, j), (i+1, j+1), (i, j+1)
                # But we need to map to linear indices

                v1 = i * h + j + 1
                v2 = (i + 1) * h + j + 1
                v3 = (i + 1) * h + (j + 1) + 1
                v4 = i * h + (j + 1) + 1

                f.write(f"f {v1} {v2} {v3} {v4}\n")

    print(f"Saved 3D mesh to {output_path}")
